{
  "name": "mock-require",
  "version": "1.3.0",
  "description": "Simple, intuitive mocking of Node.js modules.",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "caller-id": "^0.1.0"
  },
  "devDependencies": {},
  "scripts": {
    "test": "node test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/boblauer/mock-require.git"
  },
  "keywords": [
    "require",
    "dependency",
    "injection",
    "di",
    "inject",
    "swap",
    "test",
    "mock",
    "stub"
  ],
  "author": {
    "name": "Bob Lauer",
    "email": "rlauer@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/boblauer/mock-require/issues"
  },
  "homepage": "https://github.com/boblauer/mock-require",
  "engines": {
    "node": ">=0.10"
  },
  "readme": "# mock-require\n\n#### Simple, intuitive mocking of Node.js modules.\n\n[![Build Status](https://travis-ci.org/boblauer/mock-require.svg)](https://travis-ci.org/boblauer/mock-require)\n\n## About\n\nmock-require is useful if you want to mock `require` statements in Node.js.  I wrote it because I wanted something with a straight-forward API that would let me mock anything, from a single exported function to a standard library.\n\n## Usage\n\n```javascript\nvar mock = require('mock-require');\n\nmock('http', { request: function() {\n  console.log('http.request called');\n}});\n\nvar http = require('http');\nhttp.request(); // 'http.request called'\n```\n\n## API\n\n### `mock(path, mockExport)`\n\n__path__: `String`\n\nThe module you that you want to mock.  This is the same string you would pass in if you wanted to `require` the module.\n\nThis path should be relative to the current file, just as it would be if you were to `require` the module from the current file.  mock-require is smart enough to mock this module everywhere it is required, even if it's required from a different file using a different relative path.\n\n__mockExport__ : `object/function`\n\nThe function or object you want to be returned from `require`, instead of the `path` module's exports.\n\n__mockExport__ : `string`\n\nThe module you want to be returned from `require`, instead of the `path` module's export.  This allows you to replace modules with other modules.  For example, if you wanted to replace the `fs` module with the `path` module (you probably wouldn't, but if you did):\n\n```javascript\nmock('fs', 'path');\nrequire('fs') === require('path'); // true\n```\nThis is useful if you have a mock library that you want to use in multiple places.  For example:\n\n`test/spy.js`:\n```javascript\nmodule.exports = function() {\n    return 'this was mocked';\n};\n```\n\n`test/a_spec.js`:\n```javascript\nvar mock = require('mock-require');\nmock('../some/dependency', './spy');\n...\n```\n\n`test/b_spec.js`:\n```javascript\nvar mock = require('mock-require');\nmock('../some/other/dependency', './spy');\n...\n```\n\n### `mock.stop(path)`\n\n__path__: `String`\n\nThe module you that you want to stop mocking.  This is the same string you would pass in if you wanted to `require` the module.\n\nThis will only modify variables used after `mock.stop` is called.  For example:\n\n```javascript\nvar mock = require('mock-require');\nmock('fs', { mockedFS: true });\n\nvar fs1 = require('fs');\n\nmock.stop('fs');\n\nvar fs2 = require('fs');\n\nfs1 === fs2; // false\n```\n\n### `mock.stopAll()`\n\nThis function can be used to remove all registered mocks without the need to remove them individually using `mock.stop()`.\n\n```javascript\nmock('fs', {});\nmock('path', {});\n\nvar fs1 = require('fs');\nvar path1 = require('path');\n\nmock.stopAll();\n\nvar fs2 = require('fs');\nvar path2 = require('path');\n\nfs1 === fs2; // false\npath1 === path2; // false\n```\n\n### `mock.reRequire(path)`\n\n__path__: `String`\n\nThe file whose cache you want to refresh. This is useful if you're trying to mock a dependency for a file that has already been required elsewhere (possibly in another test file). Normally, Node.js will cache this file, so any mocks that you apply afterwards will have no effect. `reRequire` clears the cache and allows your mock to work.\n\n```javascript\nvar fs = require('fs');\nvar fileToTest = require('./fileToTest');\nmock('fs', {}); // fileToTest is still using the unmocked fs module\n\nfileToTest = mock.reRequire('./fileToTest'); // fileToTest is now using your mock\n```\n\nNote that if the file you are testing requires dependencies that in turn require the mock, those dependencies will still have the unmocked version. You may want to `reRequire` all of your dependencies to ensure that your mock is always being used.\n\n```javascript\nvar fs = require('fs');\nvar otherDep = require('./otherDep') // requires fs as a dependency\nvar fileToTest = require('./fileToTest'); // requires fs and otherDep as a dependency\nmock('fs', {}); // fileToTest and otherDep are still using the unmocked fs module\n\notherDep = mock.reRequire('./otherDep'); // do this to make sure fs is being mocked consistently\nfileToTest = mock.reRequire('./fileToTest');\n```\n\n## Test\n\n```\nnpm test\n```\n",
  "readmeFilename": "README.md",
  "_id": "mock-require@1.3.0",
  "dist": {
    "shasum": "ad13883d9640fbec757270ff009389f2eea8c762"
  },
  "_from": "mock-require@1.3.0",
  "_resolved": "https://registry.npmjs.org/mock-require/-/mock-require-1.3.0.tgz"
}
